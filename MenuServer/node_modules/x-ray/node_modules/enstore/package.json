{
  "name": "enstore",
  "description": "In-memory persistence for streams",
  "version": "1.0.1",
  "repository": {
    "type": "git",
    "url": "git://github.com/juliangruber/enstore.git"
  },
  "homepage": "https://github.com/juliangruber/enstore",
  "main": "index.js",
  "scripts": {
    "test": "tape test/*.js"
  },
  "dependencies": {
    "monotonic-timestamp": "0.0.8"
  },
  "devDependencies": {
    "concat-stream": "^1.4.6",
    "tape": "~0.3.3"
  },
  "keywords": [
    "stream",
    "store",
    "save",
    "persistence",
    "memory"
  ],
  "author": {
    "name": "Julian Gruber",
    "email": "mail@juliangruber.com",
    "url": "http://juliangruber.com"
  },
  "license": "MIT",
  "testling": {
    "files": "test/*.js",
    "browsers": [
      "ie/6..latest",
      "chrome/20..latest",
      "firefox/10..latest",
      "safari/5.0.5..latest",
      "opera/11.0..latest",
      "iphone/6",
      "ipad/6"
    ]
  },
  "readme": "# enstore\n\nIn-memory persistence for streams. Enables you to replay streams, even if they're not finished yet.\n\n*Need real persistence? Check out [level-store](https://github.com/juliangruber/level-store) for a fast and flexible\nstreaming storage engine based on LevelDB.*\n\n[![downloads](https://img.shields.io/npm/dm/enstore.svg)](https://www.npmjs.org/package/enstore)\n\n[![browser support](https://ci.testling.com/juliangruber/enstore.png)](https://ci.testling.com/juliangruber/enstore)\n\n## Usage\n\n```js\nvar enstore = require('enstore');\n\n// create a new store\nvar store = enstore();\n\n// store a someStream in it\nsomeStream.pipe(store.createWriteStream());\n\n// pipe everything someStream emitted to someWhereElse\n// doesn't matter if someStream already finished\nstore.createReadStream().pipe(someWhereElse);\n```\n\n## Example: Cache for browserify\n\nThis basically can be done for any streaming resource, like `fs.createReadStream()` or `request()`, that you\nwant to cache in memory.\n\n```js\nvar http = require('http');\nvar browserify = require('browserify');\nvar enstore = require('enstore');\n\n// fill the cache\nvar cache = enstore();\nbrowserify('app.js').bundle().pipe(cache.createWriteStream());\n\nhttp.createServer(function (req, res) {\n  if (req.url == '/bundle.js') {\n    // stream the bundle to the client\n    res.writeHead(200, { 'Content-Type' : 'application/javascript' });\n    store.createReadStream().pipe(res);\n  }\n});\n```\n\nTo recreate / flush the cache just overwrite the `cache` variable with a new `enstore` instance.\n\n## API\n\n### enstore()\n\nReturns a new store.\n\n### enstore#createWriteStream(opts)\n\nWritable stream that stores written data in the internal store. `opts` will be passed to the `Writable()` constructor.\n\n### enstore#createReadStream()\n\nReadable stream that emits both what is already stored and what comes in over\n`createWriteStream()` until `end` is emitted. `opts` will be passed to the `Readable()` constructor.\n\n## Installation\n\nWith [npm](http://npmjs.org) do\n\n```bash\n$ npm install enstore\n```\n\nFor the client, bundle with [browserify](https://github.com/substack/node-browserify).\n\n## License\n\n(MIT)\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/juliangruber/enstore/issues"
  },
  "_id": "enstore@1.0.1",
  "dist": {
    "shasum": "603ada399751e0e4cbd64eb3fefa35e972696f91"
  },
  "_from": "enstore@^1.0.1",
  "_resolved": "https://registry.npmjs.org/enstore/-/enstore-1.0.1.tgz"
}
